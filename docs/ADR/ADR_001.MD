# ADR-001: Database Choice — MongoDB vs PostgreSQL

**Date:** 2025-11-25  
**Status:** Accepted  
**Decision:** Use MongoDB as the primary database for the LostLink MVP.

---

## Context

The LostLink project is a smart lost & found system for a university campus. It requires features such as:

- Reporting lost/found items with flexible metadata
- Storing item descriptions, tags, and image metadata
- Text-based fuzzy search
- Geolocation-based matching
- Fast prototyping for a short delivery timeline
- Integration with Node.js backend
- Storage of nested documents (e.g., chat messages, match objects)
- Document-like items that vary in structure

The team consists of 3 developers with an 8-week MVP deadline, making rapid development and flexible data modeling essential.

The professor questioned whether SQL might be more appropriate, so this ADR explains the decision clearly.

---

## Decision

We choose MongoDB as our database for the MVP instead of PostgreSQL.

This decision is guided by the structure of our data, required features, development constraints, and project timeline.

---

## Key Reasons for Choosing MongoDB

### 1. Flexible Document-Based Schema Fits Item Data Better

Lost & found items are essentially documents, not rigid relational entities.

**Example item fields:**

- title
- description
- location coordinates
- tags
- multiple images
- fuzzy-searchable text
- optional metadata depending on item type
- chat history
- admin logs

These vary per item and benefit from a schema-flexible DB.

**Why PostgreSQL struggles:**

- It requires multiple relational tables (items, tags, images, chats…) and predefined schemas that slow iteration.

**Why MongoDB works:**

- A single document can contain all relevant nested data.

### 2. Built-in Fuzzy Text Search and Ranking

LostLink's matching system requires:

- keyword search
- partial word matching
- weighted indexing
- text scoring

**PostgreSQL supports full-text search, but it is:**

- more complex to configure
- slower to iterate on
- less flexible for rapidly evolving item descriptions

**MongoDB's text index is:**

- simple to use (`db.items.createIndex({ title: "text", description: "text" })`)
- optimized for JSON documents
- ideal for lightweight fuzzy matches
- perfect for our 8-week timeline

### 3. Built-in Geospatial Queries

The matching algorithm relies on location proximity using coordinates.

**MongoDB has:**

- native geospatial indexing (2dsphere)
- simple `$near` and `$geoWithin` queries
- straightforward distance calculations

**PostgreSQL requires:**

- complex types
- additional setup and maintenance

For a student MVP, MongoDB's geo features are significantly easier.

### 4. Faster Iteration for a 3-Person Team

**MongoDB allows:**

- evolving schemas without migrations
- rapid prototyping
- fast addition of new fields
- flexible document design

**PostgreSQL requires schema migrations for every change:**

- new columns
- new relations
- new constraints
- join table adjustments

This slows the team down and adds overhead that doesn't provide value for this project.

### 5. Better Fit for Node.js (MERN stack)

The team is building a Node + Express backend.

**MongoDB integrates naturally:**

- JSON ↔ JSON (no transformations)
- Mongoose for validation & schemas
- Native MongoDB Node driver with promises
- Cleaner data flow for a REST API

**PostgreSQL requires:**

- TypeORM or Prisma
- stricter schema management
- more boilerplate
- more rigid schemas

For a fast-paced MVP, MongoDB aligns with our DX needs.

### 6. Suited for Unstructured Chat Data

**Chats are:**

- user-generated
- highly variable
- nested
- timestamped
- stored per match case

MongoDB document structure makes this trivial.

**PostgreSQL would require:**

- multiple relational tables
- JOINs
- migrations
- overhead unnecessary for chat messages

### 7. Simplified Deployment

**MongoDB Atlas provides:**

- one-click deployment
- auto-scaling
- integrated monitoring
- shared cluster free tier
- built-in backup
- built-in connection string auth

PostgreSQL hosting setup is more involved for a student team.

---

## Why PostgreSQL Was Not Chosen

PostgreSQL is excellent for:

- strict relational integrity
- complex joins
- ACID-heavy transactional systems
- financial data
- inventory systems
- normalized schemas
- strong consistency requirements

**LostLink does not require:**

- multi-table joins
- normalized relational structures
- complex business transactions
- strict foreign-key guarantees

**Instead, LostLink benefits more from:**

- flexibility
- speed
- rapid schema evolution
- full-text search
- nested documents

Thus PostgreSQL is not the best fit for this specific project and timeline.

---

## Conclusion

MongoDB is chosen for LostLink because:

- It matches our data model
- It supports features we need (text search + geospatial)
- It integrates naturally with Node.js
- It allows fast development for a 3-person team
- It avoids migration overhead
- It supports chat, images, and flexible item descriptions
- It fits the 8-week MVP timeline
- It simplifies deployment significantly

PostgreSQL remains a valid alternative for future enterprise versions, but MongoDB provides the best fit for this MVP's requirements and constraints.

---

## Status

**Accepted**

Revisit if relational requirements increase.
