# ADR-002: Database Migration — MongoDB to PostgreSQL

**Date:** 2025-12-04  
**Status:** Accepted  
**Decision:** Migrate from MongoDB to PostgreSQL (Neon) for the LostLink backend.

---

## Context

After initial development with MongoDB (as documented in ADR-001), the LostLink project has evolved and the data model has become clearer. During implementation, we discovered that:

- The data structure is inherently relational with well-defined relationships
- Users, items, item images, and item tags form a clear relational model
- Foreign key constraints and referential integrity are important for data consistency
- The project requires ACID transactions for multi-table operations (e.g., creating items with images and tags)
- Type safety and schema validation at the database level are critical

The original MongoDB choice was made for flexibility and rapid prototyping, but as the schema stabilized, the relational nature of the data became apparent.

---

## Decision

We migrate from MongoDB to PostgreSQL (hosted on Neon) for the LostLink backend.

This decision is driven by the clear relational structure of our data model, the need for data integrity, and the benefits of using a relational database for our use case.

---

## Key Reasons for Migrating to PostgreSQL

### 1. Clear Relational Structure Between Tables

LostLink's data model has well-defined relationships that map naturally to a relational database:

**Core Relationships:**

- Users → Items (one-to-many: a user can have multiple items)
- Items → Item Images (one-to-many: an item can have multiple images)
- Items → Item Tags (many-to-many: items can have multiple tags, tags can belong to multiple items)

**Why MongoDB struggles:**

- Requires manual relationship management
- No foreign key constraints
- Risk of orphaned documents
- Complex queries for related data

**Why PostgreSQL works:**

- Native foreign key constraints ensure referential integrity
- JOIN operations are optimized and straightforward
- Cascade deletes automatically handle related records
- Clear, explicit relationships in the schema

### 2. Data Integrity and ACID Transactions

LostLink operations often involve multiple related tables:

**Example: Creating an Item**

- Insert item record
- Insert item images (one or more)
- Insert item tags (multiple)
- All must succeed or all must fail

**MongoDB limitations:**

- Multi-document transactions are possible but more complex
- No foreign key constraints to prevent invalid references
- Manual validation required for referential integrity

**PostgreSQL advantages:**

- Native ACID transactions across multiple tables
- Foreign key constraints prevent invalid data
- Cascade deletes maintain consistency automatically
- Database-level validation ensures data quality

### 3. Type Safety and Schema Validation

As the project matured, we need stricter schema enforcement:

**PostgreSQL provides:**

- Strong typing at the database level
- CHECK constraints for enum-like values (item type, status)
- NOT NULL constraints prevent missing required fields
- UNIQUE constraints ensure data uniqueness (e.g., user emails)
- Automatic schema validation on every insert/update

**MongoDB limitations:**

- Schema validation requires application-level checks
- Type mismatches can go undetected
- No database-level constraints

### 4. Better Query Performance for Relational Queries

LostLink frequently needs to:

- Fetch items with their associated images and tags
- Join user information with items
- Filter items by user, type, status, and search terms
- Count items with complex conditions

**PostgreSQL advantages:**

- Optimized JOIN operations
- Indexes on foreign keys improve join performance
- Full-text search with GIN indexes for efficient text queries
- Composite indexes for common query patterns
- Query planner optimizes complex queries automatically

**MongoDB limitations:**

- Multiple queries or complex aggregation pipelines for related data
- Less efficient for relational queries
- N+1 query problems without careful design

### 5. Geospatial Support with PostGIS

LostLink requires geospatial queries for location-based matching.

**PostgreSQL with PostGIS:**

- Industry-standard PostGIS extension
- GEOGRAPHY type for accurate coordinate storage
- Rich set of spatial functions (ST_Point, ST_Distance, etc.)
- GIST indexes for efficient spatial queries
- Better suited for future map integration (e.g., Mapbox)

**MongoDB geospatial:**

- Basic 2dsphere indexes work but are less feature-rich
- Limited spatial functions compared to PostGIS
- Less suitable for complex geospatial operations

### 6. Migration to Drizzle ORM

The migration to PostgreSQL coincided with adopting Drizzle ORM:

**Benefits:**

- Type-safe queries with TypeScript
- Schema defined in code with automatic type inference
- Better developer experience than raw SQL
- Maintainable and testable code
- Eliminates N+1 query problems with proper relations

**Drizzle with PostgreSQL:**

- Excellent TypeScript integration
- Type inference from schema
- Compile-time query validation
- Better than Mongoose for relational data

### 7. Neon Database Hosting

PostgreSQL is hosted on Neon, which provides:

**Neon advantages:**

- Serverless PostgreSQL with auto-scaling
- Branching for database environments
- Simple connection string setup
- Compatible with standard PostgreSQL drivers
- Good performance and reliability

---

## Why MongoDB Was Replaced

MongoDB served us well during initial prototyping, but as the project evolved:

**MongoDB limitations we encountered:**

- Manual relationship management became cumbersome
- No foreign key constraints led to data integrity concerns
- Complex queries for related data (items with images and tags)
- Application-level validation instead of database-level constraints
- Less efficient for our relational query patterns

**PostgreSQL addresses these:**

- Native relational model fits our data structure
- Foreign keys ensure data integrity
- Efficient JOINs for related data
- Database-level validation and constraints
- Better performance for our query patterns

---

## Migration Details

### Schema Structure

The PostgreSQL schema includes:

- **users** table: User accounts with email verification
- **items** table: Lost/found items with PostGIS geography for coordinates
- **item_images** table: Separate table for item images (MinIO URLs)
- **item_tags** table: Many-to-many relationship for tags

### Key Features

- UUID primary keys for all tables
- Foreign key constraints with CASCADE deletes
- GIN indexes for full-text search
- GIST indexes for geospatial queries
- Composite indexes for common query patterns
- Triggers for automatic `updated_at` timestamps

### Technology Stack

- **Database:** PostgreSQL 17 (Neon)
- **ORM:** Drizzle ORM with `drizzle-orm/node-postgres`
- **Extensions:** uuid-ossp, postgis
- **Connection:** Standard `pg` Pool (works with Neon connection strings)

---

## Conclusion

PostgreSQL is chosen for LostLink because:

- Our data model has clear relational structure between tables
- Foreign key constraints ensure data integrity
- ACID transactions are essential for multi-table operations
- Database-level validation prevents invalid data
- Optimized JOINs improve query performance
- PostGIS provides superior geospatial capabilities
- Drizzle ORM offers excellent TypeScript integration
- Neon provides reliable serverless PostgreSQL hosting

The migration from MongoDB to PostgreSQL reflects the evolution of the project from rapid prototyping to a more structured, production-ready system. The relational nature of our data model makes PostgreSQL the natural fit.

---

## Status

**Accepted**

This decision supersedes ADR-001 for the production implementation. MongoDB remains a valid choice for projects with truly document-based, unstructured data, but LostLink's relational structure makes PostgreSQL the better fit and architectural choice.
